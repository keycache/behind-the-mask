---
import Layout from '../layouts/Layout.astro';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
---

<Layout title="Upload - Behind the Mask">
    <Header />
    
    <main class="min-h-screen pt-24 px-4 py-8 sm:px-6 lg:px-8">
        <div class="max-w-7xl mx-auto space-y-8">
            <!-- Title Section -->
            <div class="text-center">
                <h1 class="text-3xl font-bold tracking-tight sm:text-4xl bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent">
                    Upload Your Image
                </h1>
                <p class="mt-4 text-lg text-gray-700 dark:text-gray-300">
                    Choose an image and customize your text placement
                </p>
            </div>

            <!-- Upload Section -->
            <div class="max-w-2xl mx-auto">
                <div class="bg-white dark:bg-gray-800 rounded-xl shadow-sm p-6">
                    <label 
                        for="image-upload"
                        class="flex flex-col items-center justify-center w-full h-32 border-2 border-dashed rounded-lg cursor-pointer border-gray-300 dark:border-gray-600 hover:border-purple-500 dark:hover:border-purple-500"
                    >
                        <div class="flex flex-col items-center justify-center pt-5 pb-6">
                            <svg class="w-10 h-10 mb-3 text-gray-500 dark:text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                            </svg>
                            <p class="mb-2 text-sm text-gray-700 dark:text-gray-300">
                                <span class="font-semibold">Click to upload</span> or drag and drop
                            </p>
                            <p class="text-xs text-gray-500 dark:text-gray-400">
                                PNG, JPG or WEBP (MAX. 10MB)
                            </p>
                        </div>
                        <input id="image-upload" type="file" class="hidden" accept="image/*" />
                    </label>
                </div>
            </div>

            <!-- Editor Section -->
            <div id="editor-section" class="hidden grid grid-cols-1 lg:grid-cols-3 gap-8">
                <!-- Preview Column -->
                <div class="lg:col-span-2">
                    <div id="preview-container" class="hidden">
                        <div class="relative w-full bg-white dark:bg-gray-800 rounded-xl shadow-sm p-6">
                            <img id="image-preview" class="w-full h-auto" alt="Preview" />
                            <div id="text-overlay" class="absolute pointer-events-none select-none" style="display: none; top: 0; left: 0; width: 100%; height: 100%;"></div>
                        </div>
                    </div>
                </div>

                <!-- Controls Column -->
                <div>
                    <div class="bg-white dark:bg-gray-800 rounded-xl shadow-sm p-6 space-y-6">
                        <button id="add-text-btn" class="hidden w-full bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 dark:focus:ring-offset-gray-900">
                            Add New Text
                        </button>
                        
                        <div id="text-panels" class="space-y-6">
                            <!-- Text panels will be added here dynamically -->
                        </div>

                        <button id="process-button" class="hidden w-full bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 dark:focus:ring-offset-gray-900">
                            Save Image
                        </button>
                    </div>
                    <canvas id="processing-canvas" class="hidden"></canvas>
                </div>
            </div>
        </div>
    </main>

    <Footer />
</Layout>

<script>
    interface TextSettings {
        id: string;
        content: string;
        x: number;
        y: number;
        z: number;
        fontSize: number;
        fontFamily: string;
        color: string;
        rotation: number;
    }

    let texts: TextSettings[] = [];
    let currentId = 0;

    const imageUpload = document.getElementById('image-upload') as HTMLInputElement;
    const previewContainer = document.getElementById('preview-container');
    const imagePreview = document.getElementById('image-preview') as HTMLImageElement;
    const textOverlay = document.getElementById('text-overlay') as HTMLDivElement;
    const addTextBtn = document.getElementById('add-text-btn');
    const textPanels = document.getElementById('text-panels');
    const processButton = document.getElementById('process-button');
    const canvas = document.getElementById('processing-canvas') as HTMLCanvasElement;
    const ctx = canvas.getContext('2d');

    function createTextPanel(textId: string): HTMLDivElement {
        const panel = document.createElement('div');
        panel.className = 'bg-white dark:bg-gray-800 p-4 rounded-lg shadow space-y-4 mb-4';
        panel.dataset.panelId = textId;
        
        panel.innerHTML = `
            <div class="space-y-4">
                <div class="flex justify-between items-center">
                    <h3 class="text-lg font-medium">Text Settings</h3>
                    <button class="delete-text text-red-600 hover:text-red-700">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                <div class="space-y-2">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Text Content</label>
                    <input type="text" class="text-input w-full px-3 py-2 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md" value="Sample Text" />
                </div>
                <div class="space-y-2">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">X Position</label>
                    <input type="range" class="x-position w-full" min="-50" max="150" value="0" />
                    <div class="text-sm text-gray-500 dark:text-gray-400 text-center x-position-value">0%</div>
                </div>
                <div class="space-y-2">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Y Position</label>
                    <input type="range" class="y-position w-full" min="-50" max="150" value="0" />
                    <div class="text-sm text-gray-500 dark:text-gray-400 text-center y-position-value">0%</div>
                </div>
                <div class="space-y-2">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Z Index</label>
                    <input type="range" class="z-index w-full" min="-10" max="10" value="0" />
                    <div class="text-sm text-gray-500 dark:text-gray-400 text-center z-index-value">0</div>
                </div>
                <div class="space-y-2">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Font Size</label>
                    <input type="range" class="font-size w-full" min="12" max="120" value="48" />
                    <div class="text-sm text-gray-500 dark:text-gray-400 text-center font-size-value">48px</div>
                </div>
                <div class="space-y-2">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Font Family</label>
                    <select class="font-family w-full px-3 py-2 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md">
                        <option value="Arial">Arial</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Verdana">Verdana</option>
                    </select>
                </div>
                <div class="space-y-2">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Color</label>
                    <input type="color" class="text-color w-full h-10" value="#000000" />
                </div>
                <div class="space-y-2">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Rotation</label>
                    <input type="range" class="rotation w-full" min="0" max="360" value="0" />
                    <div class="text-sm text-gray-500 dark:text-gray-400 text-center rotation-value">0°</div>
                </div>
            </div>
        `;

        // Add event listeners for all inputs
        const inputs = panel.querySelectorAll('input, select');
        inputs.forEach(input => {
            input.addEventListener('input', () => {
                const settings = getTextSettings(textId, panel);
                updateTextOverlay(settings);
                const index = texts.findIndex(t => t.id === textId);
                if (index !== -1) {
                    texts[index] = settings;
                }
            });
        });

        // Add delete button handler
        const deleteBtn = panel.querySelector('.delete-text');
        deleteBtn?.addEventListener('click', () => {
            const textElement = document.querySelector(`[data-text-id="${textId}"]`);
            textElement?.remove();
            panel.remove();
            texts = texts.filter(t => t.id !== textId);
        });

        return panel;
    }

    function getTextSettings(textId: string, panel: HTMLDivElement): TextSettings {
        return {
            id: textId,
            content: (panel.querySelector('.text-input') as HTMLInputElement).value,
            x: Number((panel.querySelector('.x-position') as HTMLInputElement).value),
            y: Number((panel.querySelector('.y-position') as HTMLInputElement).value),
            z: Number((panel.querySelector('.z-index') as HTMLInputElement).value),
            fontSize: Number((panel.querySelector('.font-size') as HTMLInputElement).value),
            fontFamily: (panel.querySelector('.font-family') as HTMLSelectElement).value,
            color: (panel.querySelector('.text-color') as HTMLInputElement).value,
            rotation: Number((panel.querySelector('.rotation') as HTMLInputElement).value)
        };
    }

    function updateTextOverlay(textSettings: TextSettings) {
        let textElement = document.querySelector(`[data-text-id="${textSettings.id}"]`) as HTMLDivElement;
        if (!textElement) {
            textElement = document.createElement('div');
            textElement.className = 'absolute text-center pointer-events-none';
            textElement.dataset.textId = textSettings.id;
            textOverlay?.appendChild(textElement);
        }

        // Update text content and basic styles
        textElement.textContent = textSettings.content;
        textElement.style.fontFamily = textSettings.fontFamily;
        
        // Scale font size relative to image height
        let imageHeight = imagePreview.height || 1000;
        const scaleFactor = imageHeight / 1000;
        const scaledFontSize = textSettings.fontSize * scaleFactor;
        textElement.style.fontSize = `${scaledFontSize}px`;
        
        textElement.style.color = textSettings.color;
        textElement.style.zIndex = textSettings.z.toString();

        // Set initial position at center
        textElement.style.position = 'absolute';
        textElement.style.left = '50%';
        textElement.style.top = '50%';
        
        // Get image dimensions for scaling
        const imageWidth = imagePreview.width;
        imageHeight = imagePreview.height;
        
        // Calculate pixel offsets based on percentages
        const xOffset = (textSettings.x / 100) * imageWidth;
        const yOffset = (textSettings.y / 100) * imageHeight;
        
        // Apply transform with pixel-based offsets
        textElement.style.transform = `
            translate(-50%, -50%)
            translate(${xOffset}px, ${yOffset}px)
            rotate(${textSettings.rotation}deg)
        `;

        // Update displays
        const panel = document.querySelector(`[data-panel-id="${textSettings.id}"]`);
        if (panel) {
            const rotationDisplay = panel.querySelector('.rotation-value');
            if (rotationDisplay) {
                rotationDisplay.textContent = `${textSettings.rotation}°`;
            }

            const zIndexDisplay = panel.querySelector('.z-index-value');
            if (zIndexDisplay) {
                zIndexDisplay.textContent = textSettings.z.toString();
            }

            const xPosDisplay = panel.querySelector('.x-position-value');
            if (xPosDisplay) {
                xPosDisplay.textContent = `${textSettings.x}%`;
            }

            const yPosDisplay = panel.querySelector('.y-position-value');
            if (yPosDisplay) {
                yPosDisplay.textContent = `${textSettings.y}%`;
            }

            const fontSizeDisplay = panel.querySelector('.font-size-value');
            if (fontSizeDisplay) {
                fontSizeDisplay.textContent = `${textSettings.fontSize}px`;
            }
        }
    }

    // Add Text Button Handler
    addTextBtn?.addEventListener('click', () => {
        const textId = `text-${currentId++}`;
        const panel = createTextPanel(textId);
        textPanels?.appendChild(panel);
        
        // Initialize with centered position
        const initialSettings = {
            id: textId,
            content: 'Sample Text',
            x: 0,
            y: 0,
            z: 0,
            fontSize: 48,
            fontFamily: 'Arial',
            color: '#000000',
            rotation: 0
        };
        
        // Create text element and update
        updateTextOverlay(initialSettings);
        texts.push(initialSettings);
    });

    // Function to render text with proper styling
    function renderText(ctx: CanvasRenderingContext2D, text: TextSettings, canvasWidth: number, canvasHeight: number) {
        ctx.save();
        
        // Scale font size relative to image height
        const scaleFactor = canvasHeight / 1000; // Use same scaling factor as preview
        const scaledFontSize = text.fontSize * scaleFactor;
        
        // Set font and color
        ctx.font = `${scaledFontSize}px ${text.fontFamily}`;
        ctx.fillStyle = text.color;
        
        // Calculate absolute positions in pixels
        const xPos = (canvasWidth * (text.x + 50)) / 100;
        const yPos = (canvasHeight * (text.y + 50)) / 100;
        
        // Move to position and rotate
        ctx.translate(xPos, yPos);
        ctx.rotate((text.rotation * Math.PI) / 180);
        
        // Center the text
        const metrics = ctx.measureText(text.content);
        ctx.fillText(text.content, -metrics.width / 2, scaledFontSize / 3);
        
        ctx.restore();
    }

    // Process and save image
    async function processImage() {
        if (!ctx || !imagePreview.complete) return;

        // Log text settings before processing
        console.log('Text Settings at Save:', JSON.stringify(texts, null, 2));

        // Set canvas size to match image
        canvas.width = imagePreview.naturalWidth;
        canvas.height = imagePreview.naturalHeight;

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw image
        ctx.drawImage(imagePreview, 0, 0);

        // Sort texts by z-index
        const sortedTexts = [...texts].sort((a, b) => a.z - b.z);

        // Draw each text
        sortedTexts.forEach(text => {
            renderText(ctx, text, canvas.width, canvas.height);
        });

        try {
            // Convert canvas to blob
            const blob = await new Promise<Blob>((resolve, reject) => {
                canvas.toBlob(blob => {
                    if (blob) {
                        resolve(blob);
                    } else {
                        reject(new Error('Canvas to Blob conversion failed'));
                    }
                }, 'image/png');
            });

            // Create download link
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'behind-the-mask-image.png';
            
            // Trigger download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Cleanup
            URL.revokeObjectURL(url);
        } catch (error) {
            console.error('Error saving image:', error);
            alert('Error saving image. Please try again.');
        }
    }

    // Add click handler for process button
    processButton?.addEventListener('click', processImage);

    // Wait for image to load before allowing processing
    imagePreview.addEventListener('load', () => {
        if (processButton) {
            processButton.disabled = false;
        }
    });

    // Initially disable process button
    if (processButton) {
        processButton.disabled = true;
    }

    // Handle image upload
    imageUpload?.addEventListener('change', async (event) => {
        const file = (event.target as HTMLInputElement).files?.[0];
        if (file && previewContainer && imagePreview && textOverlay) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const result = e.target?.result;
                if (typeof result === 'string') {
                    imagePreview.src = result;
                    
                    // Show preview container and setup overlay
                    previewContainer.classList.remove('hidden');
                    textOverlay.style.display = 'block';
                    
                    // Show the editor section and buttons
                    const editorSection = document.getElementById('editor-section');
                    if (editorSection) editorSection.classList.remove('hidden');
                    const addTextBtn = document.getElementById('add-text-btn');
                    const processBtn = document.getElementById('process-button');
                    if (addTextBtn) addTextBtn.classList.remove('hidden');
                    if (processBtn) processBtn.classList.remove('hidden');
                    
                    // Clear existing text elements when new image is uploaded
                    textOverlay.innerHTML = '';
                    texts = [];
                    if (textPanels) {
                        textPanels.innerHTML = '';
                    }
                    currentId = 1;
                    
                    // Create initial text element after image loads
                    imagePreview.onload = () => {
                        if (texts.length === 0) {
                            addTextBtn?.click();
                        }
                    };
                }
            };
            reader.readAsDataURL(file);
        }
    });

    // Handle drag and drop
    const uploadArea = document.getElementById('upload-area');

    uploadArea?.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadArea.classList.add('border-purple-500');
    });

    uploadArea?.addEventListener('dragleave', () => {
        uploadArea.classList.remove('border-purple-500');
    });

    uploadArea?.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadArea.classList.remove('border-purple-500');
        
        if (e.dataTransfer?.files.length) {
            imageUpload.files = e.dataTransfer.files;
            const event = new Event('change');
            imageUpload.dispatchEvent(event);
        }
    });
</script>
